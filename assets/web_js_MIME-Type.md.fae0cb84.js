import{_ as e,o as a,c as t,R as l}from"./chunks/framework.bf742a9e.js";const f=JSON.parse('{"title":"常见媒体类型","description":"","frontmatter":{},"headers":[],"relativePath":"web/js/MIME-Type.md","filePath":"web/js/MIME-Type.md"}'),o={name:"web/js/MIME-Type.md"},i=l('<h1 id="常见媒体类型" tabindex="-1">常见媒体类型 <a class="header-anchor" href="#常见媒体类型" aria-label="Permalink to &quot;常见媒体类型&quot;">​</a></h1><p>MIME（Multipurpose Internet Mail Extensions）网络多用途邮件扩展，告知某种扩展名的文件用特定软件打开或处理，也叫 Media Type（Internet Media Type）媒体类型。浏览器从 HTTP 消息头字段 Content-Type 得知资源类型，从而能正确处理网络中传递的资源，实际上媒体类型就是指定<code>content-type</code>的值。</p><p>用 <code>/</code> 区分类型和子类型，类型指定多个类型，子类型更加明确的指定类型。不区分大小写，惯例用小写。</p><h2 id="常见的媒体类型" tabindex="-1">常见的媒体类型： <a class="header-anchor" href="#常见的媒体类型" aria-label="Permalink to &quot;常见的媒体类型：&quot;">​</a></h2><ul><li><span style="color:blue;">text/html：HTML 格式</span></li><li><span style="color:blue;">text/plain：普通文本</span></li><li>text/xml : XML 格式</li><li><span style="color:blue;">image/* : 图片 </span></li><li>image/gif : gif 图片</li><li>image/jpg : jpg 图片</li><li>image/png : png 图片</li></ul><h2 id="以-application-开头的媒体类型" tabindex="-1">以 application 开头的媒体类型 <a class="header-anchor" href="#以-application-开头的媒体类型" aria-label="Permalink to &quot;以 application 开头的媒体类型&quot;">​</a></h2><ul><li><span style="color:blue;">application/json ：JSON 格式数据</span></li><li><span style="color:blue;">application/x-www-form-urlencoded：form 表单默认以 <code>key1=val1&amp;key2=val2</code> 的格式发送数据到服务器（表单默认提交的数据格式），并对 key 和 value 进行 url 编码&quot;</span></li><li>application/pdf：pdf 格式</li><li>application/msword ： Word 文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/xml ： XML 数据格式</li><li>application/atom+xml ：Atom XML 聚合格式</li><li>application/xhtml+xml ：XHTML 格式</li></ul><h2 id="上传文件" tabindex="-1">上传文件 <a class="header-anchor" href="#上传文件" aria-label="Permalink to &quot;上传文件&quot;">​</a></h2><ul><li><span style="color:blue;">multipart/form-data : 在表单中提交文件 enctype=&quot;multipart/form-data&quot;</span> 。也可传输<code>key=value</code> 数据，性能损耗大，不推荐。</li></ul><blockquote><p>text/xml vs application/xml</p></blockquote><p>根据<a href="https://datatracker.ietf.org/doc/html/rfc3023#section-9" target="_blank" rel="noreferrer">https://datatracker.ietf.org/doc/html/rfc3023</a>、<a href="http://www.grauw.nl/blog/entry/489/" target="_blank" rel="noreferrer">On application/xml and text/xml</a>、<a href="https://stackoverflow.com/questions/4832357/whats-the-difference-between-text-xml-vs-application-xml-for-webservice-respons" target="_blank" rel="noreferrer">What&#39;s the difference between text/xml vs application/xml for webservice response</a>，以及代码的执行结果，两者是一样的。</p><p>存在两种估计是历史问题。</p><blockquote><p>蓝色更为常用</p></blockquote>',13),r=[i];function p(n,c,s,d,m,u){return a(),t("div",null,r)}const _=e(o,[["render",p]]);export{f as __pageData,_ as default};
